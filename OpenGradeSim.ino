/*
  OpenGradeSimulator by Matt Ockendon 2019.11.14
  Modified by Brian Palmer 2020.4.6 - updated motor routine to use PID machine and added automatic trainer incline leveler
  ____                  _____               __      ____ ____ __  ___
  / __ \ ___  ___  ___  / ___/____ ___ _ ___/ /___  / __//  _//  |/  /
  / /_/ // _ \/ -_)/ _ \/ (_ // __// _ `// _  // -_)_\ \ _/ / / /|_/ /
  \____// .__/\__//_//_/\___//_/   \_,_/ \_,_/ \__//___//___//_/  /_/
   /_/
  This is the controller for a 3D printed elevation or 'grade' simulator to use with an indoor trainer
  The project in inspired by the Wahoo Kickr Climb but shares none of its underpinnings.
  Elevation is simulated on an indoor trainer by increasing resistance over that generated by frictional
  losses.
  I found the equation of a best fit line from points plotted using an online calculator of frictional losses vs speed
  and then took the residual power to calculate the incline being simulated
  Rather than using a servo linear actuator (expensive) I'm using the Arduino Nano 33 IoT BLE's built in
  accelerometers to find the position of the bicycle. This method is prone to noise and I have tried
  some filtering (moving average) to reduce this.
  The circuit:
  Arduino Nano 33 BLE
  3.3 to 5v level shifter
  L298N H bridge
  750Newton 200mm Linear Actuator
  1x2 pushbutton pad
  128x32 I2C OLED display
  3D printed parts and boxes
  At present a NPE CABLE ANT+ to BLE bridge is required
  (due to the lack of authentication in the
  AdruinoBLE library 1.1.2)
  This code is in the public domain.
  Uses the moving average filter of sebnil https://github.com/sebnil/Moving-Avarage-Filter--Arduino-Library-
  and the Flash Storage library https://github.com/sebnil/Moving-Avarage-Filter--Arduino-Library-
  // NANO 33 IoT
*/

#include <FlashStorage.h>
#include <MovingAverageFilter.h>
#include <ArduinoBLE.h>
#include <Arduino_LSM6DS3.h>
#include <Sabertooth.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <PID_v1.h>
#include "Defines.h"
#include "PushButton.h"
#include "OLEDDisplay.h"
#include "MyMenu.h"

Sabertooth ST(128); // The Sabertooth is on address 128.

// Declare our filters
MovingAverageFilter movingAverageFilter_x(9);        //
MovingAverageFilter movingAverageFilter_y(9);        // Moving average filters for the accelerometers
MovingAverageFilter movingAverageFilter_z(9);        //
MovingAverageFilter movingAverageFilter_power(8);    // 2 second power average at 4 samples per sec
MovingAverageFilter movingAverageFilter_speed(2);    // 0.5 second speed average at 4 samples per sec

// For incline declare some variables and set some default values

long previousMillis = 0;          // last time in ms
float smoothRadPitch = 0;         // variable for the pitch
double trainerIncline = 0;           // variable for the % trainerIncline (actual per accelerometers)
double trainerInclineZeroOffset = 0; // inline adjustment from auto zero trainer incline
double targetGrade = 0;           // variable for the calculated grade (aim)
double manualTargetGrade = 0;
bool trainerLeveled = false;

// motor pid params
double Kp_avg = 1, Ki_avg = 0, Kd_avg = 0;
double Kp_close = .7, Ki_close = 0, Kd_close = 0;
double Kp_avg_adj = 0.0, Ki_avg_adj = 0.00, Kd_avg_adj = 0.0;

MovingAverageFilter movingAverageFilter_Kp(8);
MovingAverageFilter movingAverageFilter_Ki(8);
MovingAverageFilter movingAverageFilter_Kd(8);

double trainerInclineErr = 0;
double Z0 = 0; // lowest point the trainer can reach.

double motorPWM = 0;
double prev_SaberSpeed = 0;
//PID       (&Input,             &Output,   &Setpoint,    Kp, Ki, Ki,     Kd, P_ON_M    Direction, Mode)
PID motorPID(&trainerInclineErr, &motorPWM, &targetGrade, Kp_avg, Ki_avg, Kd_avg, DIRECT); //P_ON_M P_ON_E

// user settings
// TODO: convert to array of user profiles. Add bikeID and Desc to allow multiple user/bike profiles.
typedef struct {
  boolean valid;
  int riderWeight;
  int wheelCircCM;
  double trainerInclineZeroOffset;
  double Kp_avg_adj;
  double Ki_avg_adj;
  double Kd_avg_adj;

} UserSettings;

UserSettings userSettings;

// Reserve a portion of flash memory to store a "UserSetting" and
// call it "userSettings_FlashStore".
FlashStorage(userSettings_FlashStore, UserSettings);

int riderWeight = 98; // trek 820 is 33.68 lbs; was 113;            // default val combined rider and bike weight
int powerTrainer = 0;             // variable for the power (W) read from bluetooth
int speedTrainer = 0;             // variable for the speed (kph) read from bluetooth
float speedMpersec = 0;           // for calculation
float resistanceWatts = 0;        // for calculation
float powerMinusResistance = 0;   // for calculation

// For power and speed declare some variables and set some default values

int wheelCircCM = 2070;           // Default val for wheel circumference in centimeters. (26 Ã— 2.125 = 2070, 700c 32 road wheel = 2300)
long WheelRevs1;                  // For speed data set 1
long Time_1;                      // For speed data set 1
long WheelRevs2;                  // For speed data set 2
long Time_2;                      // For speed data set 2
bool firstData = true;
int speedKMH;                     // Calculated speed in KM per Hr

// Custom Char Bluetooth Logo

byte customChar[] = {
  B00000,
  B00110,
  B00101,
  B10110,
  B01100,
  B10110,
  B00101,
  B00110
};

// Our BLE peripheral and characteristics

BLEDevice cablePeripheral;
BLECharacteristic speedCharacteristic;
BLECharacteristic powerCharacteristic;

///////////////////////////////// Setup ///////////////////////////////////////

void setup() {
  Serial.begin(9600);
  delay(2000);
  // Init LED
  pinMode(redLedPin, OUTPUT);             // sets the digital pin as output
  pinMode(commonHighLedPin, OUTPUT);      // sets the digital pin as output
  pinMode(greenLedPin, OUTPUT);           // sets the digital pin as output
  digitalWrite(commonHighLedPin, HIGH);   // LED common is high.
  biColorLED(true, false);

  // init motor controller
  saberToothSetup();

  // setup a pin connected to RST (A5, pin 19) to pull reset low if reset is required
  pinMode (resetPin, OUTPUT);
  digitalWrite (resetPin, HIGH);

  // init OLED display
  initOLED();

  // Check that the accelerometer is up and running else reset
  if (!IMU.begin()) {
    Serial.println("Failed to initialize IMU!");
    resetSystem();
  }

  initUserSettings();

  //turn the motor PID controller on
  motorPID.SetMode(AUTOMATIC);
  motorPID.SetOutputLimits(0, 127); // set to 1/2 the saberTooth serial range. (forward range only)
  getPIDSettings(); // contains user adjusted PID settings
  motorPID.SetTunings(Kp_avg, Ki_avg, Kd_avg);

  // begin BLE initialization reset if fails
  if (!BLE.begin()) {
    Serial.println("starting BLE failed!");
    //    displayLineLeft(0, 21, 0, F("BLE failed!"));
    //    doDisplay();
    resetSystem();
  }

  biColorLED(true, true); // red to green
  myMenu.setCurrentMenu(&mainMenuList);
}

////////////////////////////////  loop  ///////////////////////////////////////

bool debugging = false;

void loop() {

  long currentMillis = millis();

  if (currentMillis - previousMillis >= 100)
  {
    previousMillis = currentMillis;
    checkButtons();
    myMenu.doMenu();
    doDisplay();
  }
}

////////////////////////   method declarations  ///////////////////////////////


int trainerMode = 0; // levelTrainer=0 Manual=1, SmartTrainer=2
bool onTargetGrade = false;
double inputGrade = 0;

boolean gradeSim() {
  static bool firstTime = true;
  static bool trainerLeveled = false;

  static long previousSpeedandPowerMillis = 0; // the last time we queried the SmartTrainer for Speed and Power
  static double prevTargetGrade = 0;

  trainerIncline = findTrainerIncline();

  if (selectBtnPressed())
  {
    switch (trainerMode)
    {
      case 0: // levelTrainer mode
        if (firstTime)
        {
          firstTime = false;
          prevTargetGrade = inputGrade = trainerInclineZeroOffset == 0 ? trainerIncline : trainerInclineZeroOffset; // set target incline as current location if offset has never been set, otherwise use the stored offset
          return false; // skipping first cycle to ignore the selectBtnPressed that got us here.
        }
        trainerInclineZeroOffset = trainerIncline;
        updateUserSettings();
      case 1: // manual mode
        trainerMode = 2; // switching to smartTrainer mode
        break;
      case 2: // smartTrainer mode
        trainerMode = 0; // force releveling each time gradeSim is started.
        firstTime = true;
        //lowerActuator();
        //delay(5000); // allow time for actuator to lower.
        stopActuator(); // turn off motor
        return true; // exit gradeSim
    }
  }

  switch (trainerMode)
  {
    case 0: // levelTrainer mode. intentional fallthrough.
    case 1: // manual mode
      setDouble(inputGrade, 1, 45, 1); // check for manual changes in grade
      break;
    case 2: // smartTrainer mode
      if (upDownBtnPressed())
      {
        trainerMode = 1; // switching to manual mode
        return false;
      }
      if (debugging)
      {
        //powerTrainer = movingAverageFilter_power.process(210);
        //speedTrainer = movingAverageFilter_speed.process(15);
        serialReceive();
      } else {
        if (!cablePeripheral.connected())
        {
          getBLEServices(); // BLE setup
        }
        // fetch new speed and power data from trainer 5 times a second.
        long currentMillis = millis();
        if (currentMillis - previousSpeedandPowerMillis >= 200)
        {
          previousSpeedandPowerMillis = currentMillis;
          refreshSpeedandPower(); // Get any updated data
        }

        calculateTargetGrade(); // Use power and speed to calculate the targetGrade
        inputGrade = trainerInclineZeroOffset + inputGrade;
      }
      break;
  } // end switch

  targetGrade = round(inputGrade); // round to nearest whole number

  // Serial.print("inputGrade:"); Serial.print(inputGrade);
  // Serial.print("; rounded targetGrade:"); Serial.println(targetGrade);

  // Only respond to targetgrade changes if we are already locked on the previous position
  // and there has been a change of 1 degree or more.
  if (onTargetGrade && (prevTargetGrade != targetGrade))
  {
    prevTargetGrade = targetGrade;
    onTargetGrade = false;
  }

  if (!onTargetGrade)
  {
    moveActuator(); // Compute PWM and apply to motor
  }

  gradeSimDisplay(); // Display the current data
  return false;
}

void stopActuator(void) {
  ST.motor(1, 0);
}
void raiseActuator(void) {
  ST.motor(1, 127);
}
void lowerActuator(void) {
  ST.motor(1, -127);
}

void moveActuator(void)
{
  double err = targetGrade - trainerIncline;
  trainerInclineErr = -abs(err); // make err negative if it isnt already.

  int SaberSpeed = 0;
  //if (trainerInclineErr < -.20)
  if (trainerInclineErr < -.10)
  {
    //Serial.println("computing PWM");
    motorPID.SetTunings(2, 0, 0);
    biColorLED(true, false); // red
    motorPID.Compute(); // Use targetGrade and current trainer angle to calc the motor pwm value.
    SaberSpeed = motorPWM;
    //int pwm = constrain(motorPWM, 0, 255);
    //int SaberSpeed = map(pwm, 0, 255, 0, 127); // mapping default pid pwm speeds to SaberTooth SimpleSerial cmds (1 - 127)

  } else {
    Serial.println("target achieved. stopping.");
    biColorLED(true, true); // green
    SaberSpeed = 0;
    onTargetGrade = true;
  }

  if (SaberSpeed != prev_SaberSpeed)
  {
    prev_SaberSpeed = SaberSpeed;
    //    if (abs(SaberSpeed) < 23) { // stop the motor if SaberSpeed is too small to move the actuator.
    //      SaberSpeed = 0;
    //    }

    if (trainerIncline > targetGrade) {
      SaberSpeed = -abs(SaberSpeed); // flip direction if trainer is below target
    }

    ST.motor(1, SaberSpeed);
  }

  Serial.print("moveActuator targetGrade (setpoint):");  Serial.print(targetGrade);
  Serial.print(" trainerIncline:");  Serial.print(trainerIncline);

  Serial.print(" inclineErr (input):");  Serial.print(trainerInclineErr);
  Serial.print(" SaberSpeed (output):");  Serial.print(SaberSpeed);
  //  Serial.print(" Kp_avg:");
  //  Serial.print(motorPID.GetKp());
  //  Serial.print(" Ki_avg:");
  //  Serial.print(motorPID.GetKi());
  //  Serial.print(" Kd_avg:");
  //  Serial.print(motorPID.GetKd());
  Serial.println();
}

bool lowerTrainer()
{
  static bool firstTime = true;
  static double prevIncline = 0;
  static long previousMillis = 0;
  long currentMillis = millis();
  char buf[70];

  if (firstTime)
  {
    firstTime = false;
    prevIncline = trainerIncline;
    Serial.println("lowering actuator...");
    //delay(500);
    lowerActuator(); // start lowering the trainer
    sprintf_P(buf, PSTR("lowering..."), trainerIncline);
    displayLineLeft(1, 12, 1, buf);
    displayLineLeft(2, 24, 1, " "); // erase the unused line
  } else {
    if (prevIncline != trainerIncline) { // still moving down so reset
      Serial.println("still lowering...");
      prevIncline = trainerIncline;
      previousMillis = currentMillis;
    } else {
      // stopped or possibly havent started moving yet
      if (currentMillis - previousMillis >= WAIT_FOR_ACTUATOR_STOP_MIL) // have been stopped for WAIT_ACTUATOR_STOP_MIL. fini!
      {
        Serial.print(currentMillis - previousMillis);
        Serial.print(" >= ");
        Serial.println(WAIT_FOR_ACTUATOR_STOP_MIL);
        Serial.println("done lowering");
        //trainerInclineZeroOffset = trainerIncline; // zero the display
        targetGrade = trainerIncline; // initialize the starting point grade
        previousMillis = 0; // reset stuff for next time.
        firstTime = true;
        return true;
      }
    }
  }
  return false;
}

bool autoLevelTrainerIncline() {
  /* Samples the controler head grade n times and saves it as a correction offset to be applied when calculating bike grade.
    Press any key to exit without updating. Could be modified to give up and accept current offset. */

  //Serial.print("auto leveling trainer.");
  static int sampleTimes = 0;
  static int previousSample = 0;
  const int n = 30;
  trainerIncline = findTrainerIncline();

  switch (sampleTimes)
  {
    case 0:
      previousSample = trainerIncline;
    default:

      if (trainerIncline == previousSample)
      {
        sampleTimes++;
      } else {
        sampleTimes = 0; // start over
      }
      previousSample = trainerIncline;

      char buf[20];
      //sprintf_P(buf, PSTR("offset:%d%%"), trainerIncline);
      sprintf_P(buf, PSTR("hold still..."), trainerIncline);
      displayLineLeft(1, 12, 1, buf);
      displayLineLeft(2, 24, 1, " "); // erase the unused line

      bargraph(0, 27, sampleTimes * (128 / n), 6);
      //return false;
      if (pressAnyButtonToExit())
      {
        sampleTimes = previousSample = 0;
        return true;
      }
      break;
    case n: // must be same angle n times in a row to auto-stop
      trainerInclineZeroOffset = trainerIncline; // record the adjustment
      sampleTimes = 0; // reset for next time.
      trainerLeveled = true;
      return true;
      break;
  }

}

double findTrainerIncline() {
  float rawx, rawy, rawz;
  float x, y, z;
  double trainerIncline = 0;

  if (IMU.accelerationAvailable()) {
    IMU.readAcceleration(rawx, rawy, rawz);

    x = movingAverageFilter_x.process(rawx);      //
    y = movingAverageFilter_y.process(rawy);      //   Apply moving average filters to reduce noise
    z = movingAverageFilter_z.process(rawz);      //

    //    char buf[80];
    //    sprintf_P(buf, PSTR("IMU x:%d y:%d z:%d"), x, y, z);

    // find pitch in radians
    float radpitch = atan2(( y) , sqrt(x * x + z * z));

    smoothRadPitch = radpitch;

    // find the % grade from the pitch
    trainerIncline = tan(smoothRadPitch) * 100;

    trainerIncline = trainerIncline * -1; // flip the sign since its mounted with the USB port on the left.
  }

  //  char buf[5];
  //  sprintf_P(buf, PSTR("findTrainerIncline: %d"), trainerIncline);
  //  Serial.println(buf);

  return trainerIncline;

}

void calculateTargetGrade(void) {
  float speed28 = pow(speedTrainer, 2.8);                                             // pow() needed to raise y^x where x is decimal
  resistanceWatts = (0.0102 * speed28) + 9.428;                                       // calculate power from rolling / wind resistance
  powerMinusResistance = powerTrainer - resistanceWatts;                              // find power from climbing
  //Serial.print("powerMinusResistance:");
  //Serial.print(powerMinusResistance);

  speedMpersec = speedTrainer / 3.6;                                                  // find speed in SI units. 1 meter / second (m/s) is equal 3.6 kilometers / hour (km/h)
  if (speedMpersec == 0)
  {
    inputGrade = 0;
  }
  else
  {
    inputGrade = ((powerMinusResistance / (riderWeight * 9.8)) / speedMpersec) * 100; // calculate grade of climb in %
  }

  // Limit upper and lower grades
  if (inputGrade < -10) {
    inputGrade = -10;
  }
  if (inputGrade > 20) {
    inputGrade = 20;
  }
}

void gradeSimDisplay()
{
  displayLineLeft(0, 20, 1, " "); // erase line 0
  displayLineLeft(1, 20, 1, " "); // erase line 1
  displayLineLeft(2, 20, 1, " "); // erase line 2

  // --   row 1 --
  char buf[7];
  sprintf_P(buf, PSTR("%d W"), powerTrainer); // Display power in watts top left

  //displayTextLeft( row,  rowPos,  startcol,  colwidth,  textsize, message )
  displayTextLeft (0, 0, 0, 5, 1, buf);

  // Display speed top right if more than 4kph
  if (speedTrainer > 4)
  {
    sprintf_P(buf, PSTR("%d kph"), speedTrainer);
    displayTextRight(0, 0, 20, 7, 1, buf);
  } else {
    displayTextRight(0, 0, 20, 7, 1, "-- kpm");
  }

  // --   row 2 --
  //sprintf_P(buf, PSTR("%.2d%%"), trainerIncline); //  Display current trainerIncline centred and 2X-scale text
  //int adjIncline = trainerIncline - trainerInclineZeroOffset;
  //sprintf_P(buf, PSTR("%d%%"), adjIncline); //  Display current trainerIncline centered and 2X-scale text
  int tGrade = (int) targetGrade - trainerInclineZeroOffset;
  sprintf_P(buf, PSTR("%d%%"), tGrade); // Display target grade centered and 2X-scale text
  displayTextRight (1, 9, 6, 7, 2, buf);

  // --   row 3 --
  //sprintf_P(buf, PSTR("%d kg"), riderWeight); // Display weight bottom left
  sprintf_P(buf, PSTR("%g pwm"), motorPWM); // Display motor PWM bottom left
  //displayTextLeft( row,  rowPos,  startcol,  colwidth,  textsize, message )
  displayTextLeft (2, 24, 0, 9, 1, buf);

  // Display  smartTrainer target grade bottom right
  double adjTargetIncline = inputGrade - trainerInclineZeroOffset;
  switch (trainerMode) {
    case 0: // trainerLevel Mode
      sprintf_P(buf, PSTR("Level %.3g%%"), adjTargetIncline);
      break;
    case 1: // manual mode
      sprintf_P(buf, PSTR("Manual %.3g%%"), adjTargetIncline);
      break;
    case 2:
      sprintf_P(buf, PSTR("Trainer %.3g%%"), adjTargetIncline);
      break;
  }
  //void displayTextRight( row, rowPos, startcol, colwidth, textsize,  message)
  displayTextRight(2, 24, 20, 13, 1, buf);

}

void getBLEServices() {

  displayLineLeft(1, 12, 0, F("Bluetooth scanning"));
  displayLineLeft(2, 24, 1, F("for ((CABLE)) Device"));
  //displayLineLeft(2, 24, 2, F(" ")); // erase the unused line
  doDisplay();

  // entering blocking code
  while (!cablePeripheral.connected()) {
    Serial.println("BLE Central");
    Serial.println("Turn on trainer and CABLE module and check batteries");

    // Scan or rescan for BLE services
    BLE.scan();

    // check if a peripheral has been discovered and allocate it
    cablePeripheral = BLE.available();

    if (cablePeripheral) {
      // discovered a peripheral, print out address, local name, and advertised service
      Serial.print("Found ");
      Serial.print(cablePeripheral.address());
      Serial.print(" '");
      Serial.print(cablePeripheral.localName());
      Serial.print("' ");
      Serial.print(cablePeripheral.advertisedServiceUuid());
      Serial.println();

      if (cablePeripheral.localName() == ">CABLE") {
        // stop scanning
        BLE.stopScan();
        Serial.println("got CABLE device. scan stopped");

        // connect and subscribe to BLE speed and power
        getsubscribedtoSensor(cablePeripheral);

      }
    }
    delay(200);
  } // end while
}

void getsubscribedtoSensor(BLEDevice cablePeripheral) {
  //   connect to the peripheral
  Serial.println("Connecting ...");
  if (cablePeripheral.connect()) {
    Serial.println("Connected");

  } else {
    Serial.println("Failed to connect to CABLE device");
    return;
  }

  // discover Cycle Speed and Cadence attributes
  Serial.println("Discovering Cycle Speed and Cadence service ...");
  if (cablePeripheral.discoverService("1816")) {
    Serial.println("Cycle Speed and Cadence Service discovered");
  } else {
    Serial.println("Cycle Speed and Cadence Attribute discovery failed.");
    cablePeripheral.disconnect();

    resetSystem();
    return;
  }

  // discover Cycle Power attributes
  Serial.println("Discovering Cycle Power service ...");
  if (cablePeripheral.discoverService("1818")) {
    Serial.println("Cycle Power Service discovered");
  } else {
    Serial.println("Cycle Power Attribute discovery failed.");
    cablePeripheral.disconnect();

    resetSystem();
    return;
  }

  // retrieve the characteristics

  speedCharacteristic = cablePeripheral.characteristic("2a5B");
  powerCharacteristic = cablePeripheral.characteristic("2a63");

  // subscribe to the characteristics (note authentication not supported on ArduinoBLE library v1.1.2)

  if (!speedCharacteristic.subscribe()) {
    Serial.println("can not subscribe to speed");
  } else {
    Serial.println("subscribed to speed");
  };

  if (!powerCharacteristic.subscribe()) {
    Serial.println("can not subscribe to speed and power");
    delay(5000);
    resetSystem();
  } else {
    Serial.println("subscribed to speed and power");
  };

  //  The time consuming BLE setup is done.

}

void refreshSpeedandPower(void) {

  // Get updated power value
  if (powerCharacteristic.valueUpdated()) {

    // Define an array for the value
    uint8_t holdpowervalues[6] = {0, 0, 0, 0, 0, 0} ;

    // Read value into array

    powerCharacteristic.readValue(holdpowervalues, 6);

    // Power is returned as watts in location 2 and 3 (loc 0 and 1 is 8 bit flags)
    byte rawpowerValue2 = holdpowervalues[2];       // power least sig byte in HEX
    byte rawpowerValue3 = holdpowervalues[3];       // power most sig byte in HEX

    long rawpowerTotal = (rawpowerValue2 + (rawpowerValue3 * 256)); // Serial.print("Power: "); Serial.println(rawpowerTotal);

    // Use moving average filter to give '3s power'
    powerTrainer = movingAverageFilter_power.process(rawpowerTotal);
  }

  // Get speed - a bit more complication as the GATT specification calls for Cumulative Wheel Rotations and Time since wheel event
  // So we'll need to do some maths

  if (speedCharacteristic.valueUpdated()) {

    //  This value needs a 16 byte array
    uint8_t holdvalues[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} ;

    //  But I'm only going to read the first 7
    speedCharacteristic.readValue(holdvalues, 7);

    byte rawValue0 = holdvalues[0];       // binary flags 8 bit int
    byte rawValue1 = holdvalues[1];       // revolutions least significant byte in HEX
    byte rawValue2 = holdvalues[2];       // revolutions next most significant byte in HEX
    byte rawValue3 = holdvalues[3];       // revolutions next most significant byte in HEX
    byte rawValue4 = holdvalues[4];       // revolutions most significant byte in HEX
    byte rawValue5 = holdvalues[5];       // time since last wheel event least sig byte in HEX
    byte rawValue6 = holdvalues[6];       // time since last wheel event most sig byte in HEX

    if (firstData) {
      // Get cumulative wheel revolutions as little endian hex in loc 2,3 and 4 (least significant octet first)
      WheelRevs1 = (rawValue1 + (rawValue2 * 256) + (rawValue3 * 65536) + (rawValue4 * 16777216));
      // Get time since last wheel event in 1024ths of a second
      Time_1 = (rawValue5 + (rawValue6 * 256));

      firstData = false;

    } else {

      // Get second set of data
      long WheelRevsTemp = (rawValue1 + (rawValue2 * 256) + (rawValue3 * 65536) + (rawValue4 * 16777216));
      long TimeTemp = (rawValue5 + (rawValue6 * 256));

      if (WheelRevsTemp > WheelRevs1) {           // make sure the bicycle is moving
        WheelRevs2 = WheelRevsTemp;
        Time_2 = TimeTemp;
        firstData = true;

        // Find distance difference in cm and convert to km
        float distanceTravelled = ((WheelRevs2 - WheelRevs1) * wheelCircCM);
        float kmTravelled = distanceTravelled / 1000000;

        // Find time in 1024ths of a second and convert to hours
        float timeDifference = (Time_2 - Time_1);
        float timeSecs = timeDifference / 1024;
        float timeHrs = timeSecs / 3600;

        // Find speed kmh
        speedKMH = (kmTravelled / timeHrs);

        //Serial.print("  speed: ");
        //Serial.println(speedKMH, DEC);

        // Reject zero values
        if (speedKMH < 0) {} else {
          speedTrainer = movingAverageFilter_speed.process(speedKMH);  // use moving average filter to find 3s average speed
          // speedTrainer =  speedKMH;               // redundant step to allow experiments with filters
        }
      }
    }

  }
}

bool resetSystem(void) {
  Serial.println("Resetting System");
  digitalWrite (19, LOW);
  return true;
}

bool setP(void)
{
  //bool setDouble(double& val, double valMin, double valMax, double increment)
  if (setDouble(Kp_avg_adj, 0.0, 10, .1))
  {
    motorPID.SetTunings(Kp_avg, Ki_avg, Kd_avg);
    updateUserSettings();
    return true;
  } else {
    getPIDSettings();
    displayPIDParmVals();
    return false;
  }
}

bool setI(void)
{

  if (setDouble(Ki_avg_adj, 0.0, 10, 0.01))
  {
    motorPID.SetTunings(Kp_avg, Ki_avg, Kd_avg);
    updateUserSettings();
    return true;
  } else {
    getPIDSettings();
    displayPIDParmVals();
    return false;
  }
}
bool setD(void)
{

  if (setDouble(Kd_avg_adj, 0.0, 10, 0.1))
  {
    motorPID.SetTunings(Kp_avg, Ki_avg, Kd_avg);
    updateUserSettings();
    return true;
  } else {
    getPIDSettings();
    displayPIDParmVals();
    return false;
  }
}
bool setWeight(void)
{
  if (setNumber(riderWeight, 1, 1000, 1))
  {
    updateUserSettings();
    return true;
  } else {
    displayNumber(riderWeight, F(" kg"));
    return false;
  }
}

bool setWheelSize(void)
{
  if (setNumber(wheelCircCM, 1, 9999, 1))
  {
    updateUserSettings();
    return true;
  } else {
    displayNumber(wheelCircCM, F(" cm"));
    return false;
  }
}

boolean startPhoneySpeedPower()
{
  debugging = true;
  return true;
}

boolean stopPhoneySpeedPower()
{
  debugging = false;
  return true;
}

void saberToothSetup()
{
  Sabertooth ST(128); // default address 128
  SabertoothTXPinSerial.begin(9600); // 9600 is the default baud rate for Sabertooth packet serial.
  ST.autobaud(); // Send the autobaud command to the Sabertooth controller(s).
}

void displayPIDParmVals(void) {
  // Display PID values
  char buf[20];
  sprintf_P(buf, PSTR("%.2g, %.2g, %.2g"), Kp_avg, Ki_avg , Kd_avg);
  displayLineLeft(1, 12, 1, buf);
  displayLineLeft(2, 24, 1, " "); // erase the unused lines
}

void getPIDSettings() {
  // get PID setting from POTS + user adjustments and average them.

  //Kp = analogRead(A3) * 0.004;     // Serial.print("  Kp = "); Serial.print(kp);
  Kp_avg = 1.0 + Kp_avg_adj;
  //Kp_avg = movingAverageFilter_Kp.process(Kp + Kp_avg_adj); // Serial.print("  Kp_avg = "); Serial.print(Kp_avg);
  //Kp_avg = movingAverageFilter_Kp.process(Kp);

  //Ki = analogRead(A2) * 0.0005;  // Serial.print("  Ki = "); Serial.print(ki);
  Ki_avg = 0 + Ki_avg_adj;
  //Ki_avg = movingAverageFilter_Ki.process(Ki + Ki_avg_adj); //Serial.print("  Ki_avg = "); Serial.print(Ki_avg);
  //Ki_avg = movingAverageFilter_Ki.process(Ki); //Serial.print("  Ki_avg = "); Serial.print(Ki_avg);

  //Kd = analogRead(A1) * .001;     // Serial.print("  Kd = "); Serial.print(kd);
  Kd_avg = 0 + Kd_avg_adj;
  //Kd_avg = movingAverageFilter_Kd.process(Kd + Kd_avg_adj); //Serial.print("  Kd_avg = "); Serial.println(Kd_avg);
  //Kd_avg = movingAverageFilter_Kd.process(Kd); //Serial.print("  Kd_avg = "); Serial.println(Kd_avg);

  //  Serial.print("  Kd_avg_adj = "); Serial.print(Kp_avg_adj);
  //  Serial.print("  Ki_avg_adj = "); Serial.print(Ki_avg_adj);
  //  Serial.print("  Kd_avg_adj = "); Serial.print(Kd_avg_adj);

  //motorPID.SetTunings(Kp_avg, Ki_avg, Kd_avg);
}

void initUserSettings()
{
  // Read or initialize the content of "userSettings_FlashStore"
  userSettings = userSettings_FlashStore.read();

  // Intitialize flash store with default values the first time.
  if (userSettings.valid == false) {
    Serial.println("Initializing User Settings Flash Storage");
    updateUserSettings();
    return;
  }

  riderWeight = userSettings.riderWeight;
  wheelCircCM = userSettings.wheelCircCM;
  trainerInclineZeroOffset = userSettings.trainerInclineZeroOffset;
  Kp_avg_adj = userSettings.Kp_avg_adj;
  Ki_avg_adj = userSettings.Ki_avg_adj;
  Kd_avg_adj = userSettings.Kd_avg_adj;
}

void updateUserSettings()
{
  userSettings.riderWeight = riderWeight;
  userSettings.wheelCircCM = wheelCircCM;
  userSettings.trainerInclineZeroOffset = trainerInclineZeroOffset;
  userSettings.Kp_avg_adj = Kp_avg_adj;
  userSettings.Ki_avg_adj = Ki_avg_adj;
  userSettings.Kd_avg_adj = Kd_avg_adj;
  userSettings.valid = true;
  userSettings_FlashStore.write(userSettings);
}

void biColorLED(bool on, bool color1) {

  if (on) {
    if (color1)
    {
      // flip led to green
      digitalWrite(greenLedPin, LOW);    //LED green ON
      digitalWrite(redLedPin, HIGH);     //LED RED off
    } else {
      // flip led to red
      digitalWrite(greenLedPin, HIGH);   //LED green off
      digitalWrite(redLedPin, LOW);      //LED RED on
    }
  } else {
    digitalWrite(redLedPin, HIGH);        //LED RED off
  }
}
void serialReceive()
{
  if (Serial.available())
  {
    char b = Serial.read();
    Serial.flush();
    ;
    double modifier = 0.25;
    switch (b)
    {
      case '+':

        inputGrade = inputGrade + modifier;
        break;
      case '-':
        inputGrade = inputGrade - modifier;
        break;
    }

    //    Serial.print("serialReceive b:");
    //    Serial.print(b);
    Serial.print("; inputGrade:");
    Serial.println(inputGrade);
  }

}
