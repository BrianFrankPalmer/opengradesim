/*
  Original Author: OpenGradeSimulator by Matt Ockendon 2019.11.14. See https://github.com/mockendon/opengradesim
  This branch by Brian Palmer 2020.4.6 at https://github.com/BrianFrankPalmer/opengradesim
  
  ____                  _____               __      ____ ____ __  ___
  / __ \ ___  ___  ___  / ___/____ ___ _ ___/ /___  / __//  _//  |/  /
  / /_/ // _ \/ -_)/ _ \/ (_ // __// _ `// _  // -_)_\ \ _/ / / /|_/ /
  \____// .__/\__//_//_/\___//_/   \_,_/ \_,_/ \__//___//___//_/  /_/
   /_/
  "This is the controller for a 3D printed elevation or 'grade' simulator to use with an indoor trainer.
  The project in inspired by the Wahoo Kickr Climb but shares none of its underpinnings.
  Elevation is simulated on an indoor trainer by increasing resistance over that generated by frictional
  losses." - Matt Odendon

  I was inspired to build Matt Odendon's cool opengradesim project and ended up coming up with this branch 
  in the process. This version addresses a couple issues on his to-do list and adds a few other nicities. 
  
  - A manual mode was added. Pressing the up or down button switches to manual mode. Pressing the stop button returns to smart trainer mode. 
  - The blocking motor control routine was replaced with a PID controller. Now the loop() runs uninterrupted allowing the target grade 
  to be constantly adjusted. This allows for accurate grade simulations (if your not peddling).
  - Peddle vibration injecting unwanted noise into the control loop was handled by locking the position once a target grade 
  is achieved. It's only unlocked when the REQUESTED grade has changed by 1% or more. The requested grade comes from either manual input,
  Matt's calculated grade routine,  or serial console input (+, -) during debugging/testing. But does not include the Nano's noisy sensor incline data.
  So you can now shift your weight, peddle, bang on your bike, etc. and the climber wont move unless the requested grade changes.
  - A bicolor LED was added. It turns red when the the actuator is moving and green when its locked on a target grade.
  - Now allows for negative grades.
  - Added a climber leveling mode. This mode serves two functions.  It is used to physically level the trainer to 0% incline, and zeros the 
  control unit at the same time. In this mode the up and down buttons are used to level the trainer to 0% incline. Pressing the the stop button stores the
  sensor incline as an offset in flash memory. This offset is used to automatically re-level the climber and zero the control unit next time gradesim 
  is started. So now you dont have to physically move the control head to level the climber and the control head can be mounted at an angle.
  
  - Added UI setting menu that allows setting Rider/Bike Weight, Wheel Size, PID parameters, Debug Mode
  - Finished Matt's work on storage of user settings. (Rider/Bike Weight, Wheel Size, Trainer Zero offset, PID parameters). This could easily be
  expanded store multiple rider/bike profiles.
  
  The circuit: This is basically like Matt's circuit except -
  - I use a bigger actuator that requires a bigger motor driver. After experementing with a few different boards I ended up using a 
  Sabertooth 3x32 that I had from a previous project. They are pricey, but worth it. It can be controlled with 3V signal eliminating the 
  need for a logic level shifter, can be controlled with just two wires, and COMPLETELY ELIMINATED THE MOTOR WHINE AT ALL SPEEDS.
  - Uses a 3 button pad instead of 2.
  - Added a bi-color LED to indicate state.
  - Added 3 POTS for storing initial PID param values. I ended up hardcoding these values, but plan to switch to the POTS soon. These values can
  be be adjusted in Settings -> PID values.
  - Uses a Serial cable connector between the control box and the motor driver. I had planned to swap this out for a coiled 6-pin RJ-12 cable. 
  But after tripping over the serial cable a few times without causing any damage, I think I will stick with it.
  
*/

#include <FlashStorage.h>
#include <MovingAverageFilter.h>
#include <ArduinoBLE.h> // bluetooth low energy
#include <Arduino_LSM6DS3.h> // wifi, accelerometer, and gyroscope sensor
#include <Sabertooth.h> // sabertooth motor driver
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <PID_v1.h>
#include "Defines.h"
#include "PushButton.h"
#include "OLEDDisplay.h"
#include "MyMenu.h"

Sabertooth ST(128); // The Sabertooth is on address 128.

// Declare our filters
MovingAverageFilter movingAverageFilter_x(9);        //
MovingAverageFilter movingAverageFilter_y(9);        // Moving average filters for the accelerometers
MovingAverageFilter movingAverageFilter_z(9);        //
MovingAverageFilter movingAverageFilter_power(8);    // 2 second power average at 4 samples per sec
MovingAverageFilter movingAverageFilter_speed(2);    // 0.5 second speed average at 4 samples per sec

// For incline declare some variables and set some default values

long previousMillis = 0;          // last time in ms
float smoothRadPitch = 0;         // variable for the pitch
double trainerIncline = 0;           // variable for the % trainerIncline (actual per accelerometers)
double trainerInclineZeroOffset = 0; // inline adjustment from auto zero trainer incline
double targetGrade = 0;           // variable for the calculated grade (aim)
bool trainerLeveled = false;
bool onTargetGrade = false;
double inputGrade = 0;

// motor pid params
double Kp_avg = 1, Ki_avg = 0, Kd_avg = 0;
double Kp_close = .7, Ki_close = 0, Kd_close = 0;
double Kp_avg_adj = 0.0, Ki_avg_adj = 0.00, Kd_avg_adj = 0.0;

MovingAverageFilter movingAverageFilter_Kp(8);
MovingAverageFilter movingAverageFilter_Ki(8);
MovingAverageFilter movingAverageFilter_Kd(8);

double trainerInclineErr = 0;

double motorPWM = 0;
double prev_SaberSpeed = 0;
//PID       (&Input,             &Output,   &Setpoint,    Kp, Ki, Ki,     Kd, P_ON_M    Direction, Mode)
PID motorPID(&trainerInclineErr, &motorPWM, &targetGrade, Kp_avg, Ki_avg, Kd_avg, DIRECT); //P_ON_M P_ON_E

// user settings
// TODO: convert to array of user profiles. Add bikeID and Desc to allow multiple user/bike profiles.
typedef struct {
  boolean valid;
  int riderWeight;
  int wheelCircCM;
  double trainerInclineZeroOffset;
  double Kp_avg_adj;
  double Ki_avg_adj;
  double Kd_avg_adj;

} UserSettings;

UserSettings userSettings;

// Reserve a portion of flash memory to store a "UserSetting" and
// call it "userSettings_FlashStore".
FlashStorage(userSettings_FlashStore, UserSettings);

int riderWeight = 99; // trek 820 15.28 kg (33.68 lbs) + me 83.91 kg (185 lbs); was 113;            // default val combined rider and bike weight
int powerTrainer = 0;             // variable for the power (W) read from bluetooth
int speedTrainer = 0;             // variable for the speed (kph) read from bluetooth
float speedMpersec = 0;           // for calculation
float resistanceWatts = 0;        // for calculation
float powerMinusResistance = 0;   // for calculation

// For power and speed declare some variables and set some default values

int wheelCircCM = 2070;           // Default val for wheel circumference in centimeters. (26 Ã— 2.125 = 2070, 700c 32 road wheel = 2300)
long WheelRevs1;                  // For speed data set 1
long Time_1;                      // For speed data set 1
long WheelRevs2;                  // For speed data set 2
long Time_2;                      // For speed data set 2
bool firstData = true;
int speedKMH;                     // Calculated speed in KM per Hr

// Custom Char Bluetooth Logo

byte customChar[] = {
  B00000,
  B00110,
  B00101,
  B10110,
  B01100,
  B10110,
  B00101,
  B00110
};

// Our BLE peripheral and characteristics

BLEDevice cablePeripheral;
BLECharacteristic speedCharacteristic;
BLECharacteristic powerCharacteristic;

enum TrainerMode {
  LevelTrainer,
  Manual,
  SmartTrainer
};

TrainerMode trainerMode = LevelTrainer;

///////////////////////////////// Setup ///////////////////////////////////////

void setup() {
  Serial.begin(9600);
  delay(2000);
  // Init LED
  pinMode(redLedPin, OUTPUT);             // sets the digital pin as output
  pinMode(commonHighLedPin, OUTPUT);      // sets the digital pin as output
  pinMode(greenLedPin, OUTPUT);           // sets the digital pin as output
  digitalWrite(commonHighLedPin, HIGH);   // LED common is high.
  biColorLED(true, false);

  // init motor controller
  saberToothSetup();

  // setup a pin connected to RST (A5, pin 19) to pull reset low if reset is required
  pinMode (resetPin, OUTPUT);
  digitalWrite (resetPin, HIGH);

  // init OLED display
  initOLED();

  // Check that the accelerometer is up and running else reset
  if (!IMU.begin()) {
    Serial.println("Failed to initialize IMU!");
    resetSystem();
  }

  initUserSettings();

  //turn the motor PID controller on
  motorPID.SetMode(AUTOMATIC);
  motorPID.SetOutputLimits(0, 127); // set to 1/2 the saberTooth serial range. (forward range only)
  getPIDSettings(); // contains user adjusted PID settings
  motorPID.SetTunings(Kp_avg, Ki_avg, Kd_avg);

  // begin BLE initialization reset if fails
  if (!BLE.begin()) {
    Serial.println("starting BLE failed!");
    //    displayLineLeft(0, 21, 0, F("BLE failed!"));
    //    doDisplay();
    resetSystem();
  }

  biColorLED(true, true); // red to green
  myMenu.setCurrentMenu(&mainMenuList);
}

////////////////////////////////  loop  ///////////////////////////////////////

bool debugging = false;

void loop() {

  long currentMillis = millis();

  if (currentMillis - previousMillis >= 100)
  {
    previousMillis = currentMillis;
    checkButtons();
    myMenu.doMenu();
    doDisplay();
  }
}

////////////////////////   method declarations  ///////////////////////////////

boolean gradeSim() {
  static bool firstTime = true;
  static bool trainerLeveled = false;

  static long previousSpeedandPowerMillis = 0; // the last time we queried the SmartTrainer for Speed and Power
  static double prevTargetGrade = 0;

  trainerIncline = findTrainerIncline();

  if (selectBtnPressed())
  {
    switch (trainerMode)
    {
      case LevelTrainer: 
        if (firstTime)
        {
          firstTime = false;
          prevTargetGrade = inputGrade = trainerInclineZeroOffset == 0 ? trainerIncline : trainerInclineZeroOffset; // set target incline as current location if offset has never been set, otherwise use the stored offset
          return false; // skipping first cycle to ignore the selectBtnPressed that got us here.
        }
        trainerInclineZeroOffset = trainerIncline;
        updateUserSettings();
      case Manual:
        trainerMode = SmartTrainer; // switching to smartTrainer mode
        break;
      case SmartTrainer: 
        trainerMode = Manual; // force releveling each time gradeSim is started.
        firstTime = true;
        //lowerActuator();
        //delay(5000); // allow time for actuator to lower.
        stopActuator(); // turn off motor
        return true; // exit gradeSim
    }
  }

  switch (trainerMode)
  {
    case LevelTrainer: // intentional fallthrough.
    case Manual: 
      setDouble(inputGrade, 1, 45, 1); // check for manual changes in grade
      break;
    case SmartTrainer:
      if (upDownBtnPressed())
      {
        trainerMode = Manual; // switching to manual mode
        return false;
      }
      if (debugging)
      {
        //powerTrainer = movingAverageFilter_power.process(210);
        //speedTrainer = movingAverageFilter_speed.process(15);
        serialReceive();
      } else {
        if (!cablePeripheral.connected())
        {
          getBLEServices(); // BLE setup
        }
        // fetch new speed and power data from trainer 5 times a second.
        long currentMillis = millis();
        if (currentMillis - previousSpeedandPowerMillis >= 200)
        {
          previousSpeedandPowerMillis = currentMillis;
          refreshSpeedandPower(); // Get any updated data
        }

        calculateTargetGrade(); // Use power and speed to calculate the targetGrade
        inputGrade = trainerInclineZeroOffset + inputGrade;
      }
      break;
  } // end switch

  targetGrade = round(inputGrade); // round to nearest whole number

  // Only respond to targetgrade changes if we are already locked on the previous position
  // and there has been a change of 1% or more.
  if (onTargetGrade && (prevTargetGrade != targetGrade))
  {
    prevTargetGrade = targetGrade;
    onTargetGrade = false;
  }

  if (!onTargetGrade)
  {
    moveActuator(); // Compute PWM and apply to motor
  }

  gradeSimDisplay(); // Display the current data
  return false;
}

void stopActuator(void) {
  ST.motor(1, 0);
}
void raiseActuator(void) {
  ST.motor(1, 127);
}
void lowerActuator(void) {
  ST.motor(1, -127);
}

void moveActuator(void)
{
  double err = targetGrade - trainerIncline;
  trainerInclineErr = -abs(err); // make err negative if it isnt already.

  int SaberSpeed = 0;
  //if (trainerInclineErr < -.20)
  if (trainerInclineErr < -.10)
  {
    //Serial.println("computing PWM");
    motorPID.SetTunings(2, 0, 0);
    biColorLED(true, false); // red
    motorPID.Compute(); // Use targetGrade and current trainer angle to calc the motor pwm value.
    SaberSpeed = motorPWM;
    //int pwm = constrain(motorPWM, 0, 255);
    //int SaberSpeed = map(pwm, 0, 255, 0, 127); // mapping default pid pwm speeds to SaberTooth SimpleSerial cmds (1 - 127)

  } else {
    Serial.println("target achieved. stopping.");
    biColorLED(true, true); // green
    SaberSpeed = 0;
    onTargetGrade = true;
  }

  if (SaberSpeed != prev_SaberSpeed)
  {
    prev_SaberSpeed = SaberSpeed;
    //    if (abs(SaberSpeed) < 23) { // stop the motor if SaberSpeed is too small to move the actuator.
    //      SaberSpeed = 0;
    //    }

    if (trainerIncline > targetGrade) {
      SaberSpeed = -abs(SaberSpeed); // flip direction if trainer is below target
    }

    ST.motor(1, SaberSpeed);
  }

  Serial.print("moveActuator targetGrade (setpoint):");  Serial.print(targetGrade);
  Serial.print(" trainerIncline:");  Serial.print(trainerIncline);

  Serial.print(" inclineErr (input):");  Serial.print(trainerInclineErr);
  Serial.print(" SaberSpeed (output):");  Serial.print(SaberSpeed);
  //  Serial.print(" Kp_avg:");
  //  Serial.print(motorPID.GetKp());
  //  Serial.print(" Ki_avg:");
  //  Serial.print(motorPID.GetKi());
  //  Serial.print(" Kd_avg:");
  //  Serial.print(motorPID.GetKd());
  Serial.println();
}

bool lowerTrainer()
{
  // Purpose: This non-blocking routine to lower linear acuator and shut-off motor ASAP. Will return true 
  // soon after the actuator is stopped by the limit switches. It does this by detecting
  // when the grade changes have stopped for WAIT_FOR_ACTUATOR_STOP_MIL.
  // Usage - Call from your control loop until it returns true.
  
  static bool firstTime = true;
  static double prevIncline = 0;
  static long previousMillis = 0;
  long currentMillis = millis();
  char buf[70];

  if (firstTime)
  {
    firstTime = false;
    prevIncline = trainerIncline;
    Serial.println("lowering actuator...");
    lowerActuator(); // start lowering the trainer
    sprintf_P(buf, PSTR("lowering..."), trainerIncline);
    displayLineLeft(1, 12, 1, buf);
    displayLineLeft(2, 24, 1, " "); // erase the unused line
  } else {
    if (prevIncline != trainerIncline) { // still moving down so reset
      Serial.println("still lowering...");
      prevIncline = trainerIncline;
      previousMillis = currentMillis;
    } else {
      // stopped or possibly havent started moving yet
      if (currentMillis - previousMillis >= WAIT_FOR_ACTUATOR_STOP_MIL) // have been stopped for WAIT_ACTUATOR_STOP_MIL. fini!
      {
        Serial.print(currentMillis - previousMillis);
        Serial.print(" >= ");
        Serial.println(WAIT_FOR_ACTUATOR_STOP_MIL);
        Serial.println("done lowering");
        //trainerInclineZeroOffset = trainerIncline; // zero the display
        targetGrade = trainerIncline; // initialize the starting point grade
        previousMillis = 0; // reset stuff for next time.
        firstTime = true;
        return true;
      }
    }
  }
  return false;
}

bool autoLevelTrainerIncline() {
  /* Samples the controler head grade n times and saves it as a correction offset to be applied when calculating bike grade.
    Press any key to exit without updating. Could be modified to give up and accept current offset. 
    usage: displays a bar graph indicating progress. bargraph is reset and routine starts over if movement is detected while
    averaging. I ended up not using this for anything, but it is kinda cool. Will be useful for some other project. */

  //Serial.print("auto leveling trainer.");
  static int sampleTimes = 0;
  static int previousSample = 0;
  const int n = 30;
  trainerIncline = findTrainerIncline();

  switch (sampleTimes)
  {
    case 0:
      previousSample = trainerIncline;
    default:

      if (trainerIncline == previousSample)
      {
        sampleTimes++;
      } else {
        sampleTimes = 0; // start over
      }
      previousSample = trainerIncline;

      char buf[20];
      //sprintf_P(buf, PSTR("offset:%d%%"), trainerIncline);
      sprintf_P(buf, PSTR("hold still..."), trainerIncline);
      displayLineLeft(1, 12, 1, buf);
      displayLineLeft(2, 24, 1, " "); // erase the unused line

      bargraph(0, 27, sampleTimes * (128 / n), 6);
      //return false;
      if (pressAnyButtonToExit())
      {
        sampleTimes = previousSample = 0;
        return true;
      }
      break;
    case n: // must be same angle n times in a row to auto-stop
      trainerInclineZeroOffset = trainerIncline; // record the adjustment
      sampleTimes = 0; // reset for next time.
      trainerLeveled = true;
      return true;
      break;
  }

}

double findTrainerIncline() {
  float rawx, rawy, rawz;
  float x, y, z;
  double trainerIncline = 0;

  if (IMU.accelerationAvailable()) {
    IMU.readAcceleration(rawx, rawy, rawz);

    x = movingAverageFilter_x.process(rawx);      //
    y = movingAverageFilter_y.process(rawy);      //   Apply moving average filters to reduce noise
    z = movingAverageFilter_z.process(rawz);      //

    //    char buf[80];
    //    sprintf_P(buf, PSTR("IMU x:%d y:%d z:%d"), x, y, z);

    // find pitch in radians
    float radpitch = atan2(( y) , sqrt(x * x + z * z));

    smoothRadPitch = radpitch;

    // find the % grade from the pitch
    trainerIncline = tan(smoothRadPitch) * 100;

    trainerIncline = trainerIncline * -1; // flip the sign since its mounted with the USB port on the left.
  }


  //  char buf[5];
  //  sprintf_P(buf, PSTR("findTrainerIncline: %d"), trainerIncline);
  //  Serial.println(buf);

  return trainerIncline;

}

void calculateTargetGrade(void) {
  float speed28 = pow(speedTrainer, 2.8);                                             // pow() needed to raise y^x where x is decimal
  resistanceWatts = (0.0102 * speed28) + 9.428;                                       // calculate power from rolling / wind resistance
  powerMinusResistance = powerTrainer - resistanceWatts;                              // find power from climbing
  //Serial.print("powerMinusResistance:");
  //Serial.print(powerMinusResistance);

  speedMpersec = speedTrainer / 3.6;                                                  // find speed in SI units. 1 meter / second (m/s) is equal 3.6 kilometers / hour (km/h)
  if (speedMpersec == 0)
  {
    inputGrade = 0;
  }
  else
  {
    inputGrade = ((powerMinusResistance / (riderWeight * 9.8)) / speedMpersec) * 100; // calculate grade of climb in %
  }

  // Limit upper and lower grades
  if (inputGrade < -10) {
    inputGrade = -10;
  }
  if (inputGrade > 20) {
    inputGrade = 20;
  }
}

void gradeSimDisplay()
{
  displayLineLeft(0, 20, 1, " "); // erase line 0
  displayLineLeft(1, 20, 1, " "); // erase line 1
  displayLineLeft(2, 20, 1, " "); // erase line 2

  // --   row 1 --
  char buf[7];
  sprintf_P(buf, PSTR("%d W"), powerTrainer); // Display power in watts top left

  //displayTextLeft( row,  rowPos,  startcol,  colwidth,  textsize, message )
  displayTextLeft (0, 0, 0, 5, 1, buf);

  // Display speed top right if more than 4kph
  if (speedTrainer > 4)
  {
    sprintf_P(buf, PSTR("%d kph"), speedTrainer);
    displayTextRight(0, 0, 20, 7, 1, buf);
  } else {
    displayTextRight(0, 0, 20, 7, 1, "-- kpm");
  }

  // --   row 2 --
  //sprintf_P(buf, PSTR("%.2d%%"), trainerIncline); //  Display current trainerIncline centred and 2X-scale text
  //int adjIncline = trainerIncline - trainerInclineZeroOffset;
  //sprintf_P(buf, PSTR("%d%%"), adjIncline); //  Display current trainerIncline centered and 2X-scale text
  int tGrade = (int) targetGrade - trainerInclineZeroOffset;
  sprintf_P(buf, PSTR("%d%%"), tGrade); // Display target grade centered and 2X-scale text
  displayTextRight (1, 9, 6, 7, 2, buf);

  // --   row 3 --
  //sprintf_P(buf, PSTR("%d kg"), riderWeight); // Display weight bottom left
  sprintf_P(buf, PSTR("%g pwm"), motorPWM); // Display motor PWM bottom left
  //displayTextLeft( row,  rowPos,  startcol,  colwidth,  textsize, message )
  displayTextLeft (2, 24, 0, 9, 1, buf);

  // Display  smartTrainer target grade bottom right
  double adjTargetIncline = inputGrade - trainerInclineZeroOffset;
  switch (trainerMode) {
    case 0: // trainerLevel Mode
      sprintf_P(buf, PSTR("Level %.3g%%"), adjTargetIncline);
      break;
    case 1: // manual mode
      sprintf_P(buf, PSTR("Manual %.3g%%"), adjTargetIncline);
      break;
    case 2:
      sprintf_P(buf, PSTR("Trainer %.3g%%"), adjTargetIncline);
      break;
  }
  //void displayTextRight( row, rowPos, startcol, colwidth, textsize,  message)
  displayTextRight(2, 24, 20, 13, 1, buf);

}

void getBLEServices() {

  displayLineLeft(1, 12, 0, F("Bluetooth scanning"));
  displayLineLeft(2, 24, 1, F("for ((CABLE)) Device"));
  //displayLineLeft(2, 24, 2, F(" ")); // erase the unused line
  doDisplay();

  // entering blocking code
  while (!cablePeripheral.connected()) {
    Serial.println("BLE Central");
    Serial.println("Turn on trainer and CABLE module and check batteries");

    // Scan or rescan for BLE services
    BLE.scan();

    // check if a peripheral has been discovered and allocate it
    cablePeripheral = BLE.available();

    if (cablePeripheral) {
      // discovered a peripheral, print out address, local name, and advertised service
      Serial.print("Found ");
      Serial.print(cablePeripheral.address());
      Serial.print(" '");
      Serial.print(cablePeripheral.localName());
      Serial.print("' ");
      Serial.print(cablePeripheral.advertisedServiceUuid());
      Serial.println();

      if (cablePeripheral.localName() == ">CABLE") {
        // stop scanning
        BLE.stopScan();
        Serial.println("got CABLE device. scan stopped");

        // connect and subscribe to BLE speed and power
        getsubscribedtoSensor(cablePeripheral);

      }
    }
    delay(200);
  } // end while
}

void getsubscribedtoSensor(BLEDevice cablePeripheral) {
  //   connect to the peripheral
  Serial.println("Connecting ...");
  if (cablePeripheral.connect()) {
    Serial.println("Connected");

  } else {
    Serial.println("Failed to connect to CABLE device");
    return;
  }

  // discover Cycle Speed and Cadence attributes
  Serial.println("Discovering Cycle Speed and Cadence service ...");
  if (cablePeripheral.discoverService("1816")) {
    Serial.println("Cycle Speed and Cadence Service discovered");
  } else {
    Serial.println("Cycle Speed and Cadence Attribute discovery failed.");
    cablePeripheral.disconnect();

    resetSystem();
    return;
  }

  // discover Cycle Power attributes
  Serial.println("Discovering Cycle Power service ...");
  if (cablePeripheral.discoverService("1818")) {
    Serial.println("Cycle Power Service discovered");
  } else {
    Serial.println("Cycle Power Attribute discovery failed.");
    cablePeripheral.disconnect();

    resetSystem();
    return;
  }

  // retrieve the characteristics

  speedCharacteristic = cablePeripheral.characteristic("2a5B");
  powerCharacteristic = cablePeripheral.characteristic("2a63");

  // subscribe to the characteristics (note authentication not supported on ArduinoBLE library v1.1.2)

  if (!speedCharacteristic.subscribe()) {
    Serial.println("can not subscribe to speed");
  } else {
    Serial.println("subscribed to speed");
  };

  if (!powerCharacteristic.subscribe()) {
    Serial.println("can not subscribe to speed and power");
    delay(5000);
    resetSystem();
  } else {
    Serial.println("subscribed to speed and power");
  };

  //  The time consuming BLE setup is done.

}

void refreshSpeedandPower(void) {

  // Get updated power value
  if (powerCharacteristic.valueUpdated()) {

    // Define an array for the value
    uint8_t holdpowervalues[6] = {0, 0, 0, 0, 0, 0} ;

    // Read value into array

    powerCharacteristic.readValue(holdpowervalues, 6);

    // Power is returned as watts in location 2 and 3 (loc 0 and 1 is 8 bit flags)
    byte rawpowerValue2 = holdpowervalues[2];       // power least sig byte in HEX
    byte rawpowerValue3 = holdpowervalues[3];       // power most sig byte in HEX

    long rawpowerTotal = (rawpowerValue2 + (rawpowerValue3 * 256)); // Serial.print("Power: "); Serial.println(rawpowerTotal);

    // Use moving average filter to give '3s power'
    powerTrainer = movingAverageFilter_power.process(rawpowerTotal);
  }

  // Get speed - a bit more complication as the GATT specification calls for Cumulative Wheel Rotations and Time since wheel event
  // So we'll need to do some maths

  if (speedCharacteristic.valueUpdated()) {

    //  This value needs a 16 byte array
    uint8_t holdvalues[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} ;

    //  But I'm only going to read the first 7
    speedCharacteristic.readValue(holdvalues, 7);

    byte rawValue0 = holdvalues[0];       // binary flags 8 bit int
    byte rawValue1 = holdvalues[1];       // revolutions least significant byte in HEX
    byte rawValue2 = holdvalues[2];       // revolutions next most significant byte in HEX
    byte rawValue3 = holdvalues[3];       // revolutions next most significant byte in HEX
    byte rawValue4 = holdvalues[4];       // revolutions most significant byte in HEX
    byte rawValue5 = holdvalues[5];       // time since last wheel event least sig byte in HEX
    byte rawValue6 = holdvalues[6];       // time since last wheel event most sig byte in HEX

    if (firstData) {
      // Get cumulative wheel revolutions as little endian hex in loc 2,3 and 4 (least significant octet first)
      WheelRevs1 = (rawValue1 + (rawValue2 * 256) + (rawValue3 * 65536) + (rawValue4 * 16777216));
      // Get time since last wheel event in 1024ths of a second
      Time_1 = (rawValue5 + (rawValue6 * 256));

      firstData = false;

    } else {

      // Get second set of data
      long WheelRevsTemp = (rawValue1 + (rawValue2 * 256) + (rawValue3 * 65536) + (rawValue4 * 16777216));
      long TimeTemp = (rawValue5 + (rawValue6 * 256));

      if (WheelRevsTemp > WheelRevs1) {           // make sure the bicycle is moving
        WheelRevs2 = WheelRevsTemp;
        Time_2 = TimeTemp;
        firstData = true;

        // Find distance difference in cm and convert to km
        float distanceTravelled = ((WheelRevs2 - WheelRevs1) * wheelCircCM);
        float kmTravelled = distanceTravelled / 1000000;

        // Find time in 1024ths of a second and convert to hours
        float timeDifference = (Time_2 - Time_1);
        float timeSecs = timeDifference / 1024;
        float timeHrs = timeSecs / 3600;

        // Find speed kmh
        speedKMH = (kmTravelled / timeHrs);

        //Serial.print("  speed: ");
        //Serial.println(speedKMH, DEC);

        // Reject zero values
        if (speedKMH < 0) {} else {
          speedTrainer = movingAverageFilter_speed.process(speedKMH);  // use moving average filter to find 3s average speed
          // speedTrainer =  speedKMH;               // redundant step to allow experiments with filters
        }
      }
    }

  }
}

bool resetSystem(void) {
  Serial.println("Resetting System");
  digitalWrite (19, LOW);
  return true;
}

bool setP(void)
{
  //bool setDouble(double& val, double valMin, double valMax, double increment)
  if (setDouble(Kp_avg_adj, 0.0, 10, .1))
  {
    motorPID.SetTunings(Kp_avg, Ki_avg, Kd_avg);
    updateUserSettings();
    return true;
  } else {
    getPIDSettings();
    displayPIDParmVals();
    return false;
  }
}

bool setI(void)
{

  if (setDouble(Ki_avg_adj, 0.0, 10, 0.01))
  {
    motorPID.SetTunings(Kp_avg, Ki_avg, Kd_avg);
    updateUserSettings();
    return true;
  } else {
    getPIDSettings();
    displayPIDParmVals();
    return false;
  }
}
bool setD(void)
{

  if (setDouble(Kd_avg_adj, 0.0, 10, 0.1))
  {
    motorPID.SetTunings(Kp_avg, Ki_avg, Kd_avg);
    updateUserSettings();
    return true;
  } else {
    getPIDSettings();
    displayPIDParmVals();
    return false;
  }
}
bool setWeight(void)
{
  if (setNumber(riderWeight, 1, 1000, 1))
  {
    updateUserSettings();
    return true;
  } else {
    displayNumber(riderWeight, F(" kg"));
    return false;
  }
}

bool setWheelSize(void)
{
  if (setNumber(wheelCircCM, 1, 9999, 1))
  {
    updateUserSettings();
    return true;
  } else {
    displayNumber(wheelCircCM, F(" cm"));
    return false;
  }
}

boolean startPhoneySpeedPower()
{
  debugging = true;
  return true;
}

boolean stopPhoneySpeedPower()
{
  debugging = false;
  return true;
}

void saberToothSetup()
{
  Sabertooth ST(128); // default address 128
  SabertoothTXPinSerial.begin(9600); // 9600 is the default baud rate for Sabertooth packet serial.
  ST.autobaud(); // Send the autobaud command to the Sabertooth controller(s).
}

void displayPIDParmVals(void) {
  // Display PID values
  char buf[20];
  sprintf_P(buf, PSTR("%.2g, %.2g, %.2g"), Kp_avg, Ki_avg , Kd_avg);
  displayLineLeft(1, 12, 1, buf);
  displayLineLeft(2, 24, 1, " "); // erase the unused lines
}

void getPIDSettings() {
  // get PID setting from POTS + user adjustments and average them.

  Kp_avg = 1.0 + Kp_avg_adj;
  //Kp_avg = movingAverageFilter_Kp.process(Kp + Kp_avg_adj); // Serial.print("  Kp_avg = "); Serial.print(Kp_avg);
  //Kp_avg = movingAverageFilter_Kp.process(Kp);

  //Ki = analogRead(A2) * 0.0005;  // Serial.print("  Ki = "); Serial.print(ki);
  Ki_avg = 0 + Ki_avg_adj;
  //Ki_avg = movingAverageFilter_Ki.process(Ki + Ki_avg_adj); //Serial.print("  Ki_avg = "); Serial.print(Ki_avg);
  //Ki_avg = movingAverageFilter_Ki.process(Ki); //Serial.print("  Ki_avg = "); Serial.print(Ki_avg);

  //Kd = analogRead(A1) * .001;     // Serial.print("  Kd = "); Serial.print(kd);
  Kd_avg = 0 + Kd_avg_adj;
  //Kd_avg = movingAverageFilter_Kd.process(Kd + Kd_avg_adj); //Serial.print("  Kd_avg = "); Serial.println(Kd_avg);
  //Kd_avg = movingAverageFilter_Kd.process(Kd); //Serial.print("  Kd_avg = "); Serial.println(Kd_avg);

  //  Serial.print("  Kd_avg_adj = "); Serial.print(Kp_avg_adj);
  //  Serial.print("  Ki_avg_adj = "); Serial.print(Ki_avg_adj);
  //  Serial.print("  Kd_avg_adj = "); Serial.print(Kd_avg_adj);

  //motorPID.SetTunings(Kp_avg, Ki_avg, Kd_avg);
}

void initUserSettings()
{
  // Read or initialize the content of "userSettings_FlashStore"
  userSettings = userSettings_FlashStore.read();

  // Intitialize flash store with default values the first time.
  if (userSettings.valid == false) {
    Serial.println("Initializing User Settings Flash Storage");
    updateUserSettings();
    return;
  }

  riderWeight = userSettings.riderWeight;
  wheelCircCM = userSettings.wheelCircCM;
  trainerInclineZeroOffset = userSettings.trainerInclineZeroOffset;
  Kp_avg_adj = userSettings.Kp_avg_adj;
  Ki_avg_adj = userSettings.Ki_avg_adj;
  Kd_avg_adj = userSettings.Kd_avg_adj;
}

void updateUserSettings()
{
  userSettings.riderWeight = riderWeight;
  userSettings.wheelCircCM = wheelCircCM;
  userSettings.trainerInclineZeroOffset = trainerInclineZeroOffset;
  userSettings.Kp_avg_adj = Kp_avg_adj;
  userSettings.Ki_avg_adj = Ki_avg_adj;
  userSettings.Kd_avg_adj = Kd_avg_adj;
  userSettings.valid = true;
  userSettings_FlashStore.write(userSettings);
}

void biColorLED(bool on, bool color1) {

  if (on) {
    if (color1)
    {
      // flip led to green
      digitalWrite(greenLedPin, LOW);    //LED green ON
      digitalWrite(redLedPin, HIGH);     //LED RED off
    } else {
      // flip led to red
      digitalWrite(greenLedPin, HIGH);   //LED green off
      digitalWrite(redLedPin, LOW);      //LED RED on
    }
  } else {
    digitalWrite(redLedPin, HIGH);        //LED RED off
  }
}
void serialReceive()
{
  if (Serial.available())
  {
    char b = Serial.read();
    Serial.flush();
    ;
    double modifier = 0.25;
    switch (b)
    {
      case '+':

        inputGrade = inputGrade + modifier;
        break;
      case '-':
        inputGrade = inputGrade - modifier;
        break;
    }

    //    Serial.print("serialReceive b:");
    //    Serial.print(b);
    Serial.print("; inputGrade:");
    Serial.println(inputGrade);
  }

}
